/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef distributedML_TYPES_H
#define distributedML_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace distributedML {

class Weights;

class Gradient;

class ComputeNodeInfo;

typedef struct _Weights__isset {
  _Weights__isset() : W(false), V(false) {}
  bool W :1;
  bool V :1;
} _Weights__isset;

class Weights : public virtual ::apache::thrift::TBase {
 public:

  Weights(const Weights&);
  Weights& operator=(const Weights&);
  Weights() noexcept {
  }

  virtual ~Weights() noexcept;
  std::vector<std::vector<double> >  W;
  std::vector<std::vector<double> >  V;

  _Weights__isset __isset;

  void __set_W(const std::vector<std::vector<double> > & val);

  void __set_V(const std::vector<std::vector<double> > & val);

  bool operator == (const Weights & rhs) const
  {
    if (!(W == rhs.W))
      return false;
    if (!(V == rhs.V))
      return false;
    return true;
  }
  bool operator != (const Weights &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Weights & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Weights &a, Weights &b);

std::ostream& operator<<(std::ostream& out, const Weights& obj);

typedef struct _Gradient__isset {
  _Gradient__isset() : dW(false), dV(false) {}
  bool dW :1;
  bool dV :1;
} _Gradient__isset;

class Gradient : public virtual ::apache::thrift::TBase {
 public:

  Gradient(const Gradient&);
  Gradient& operator=(const Gradient&);
  Gradient() noexcept {
  }

  virtual ~Gradient() noexcept;
  std::vector<std::vector<double> >  dW;
  std::vector<std::vector<double> >  dV;

  _Gradient__isset __isset;

  void __set_dW(const std::vector<std::vector<double> > & val);

  void __set_dV(const std::vector<std::vector<double> > & val);

  bool operator == (const Gradient & rhs) const
  {
    if (!(dW == rhs.dW))
      return false;
    if (!(dV == rhs.dV))
      return false;
    return true;
  }
  bool operator != (const Gradient &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Gradient & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Gradient &a, Gradient &b);

std::ostream& operator<<(std::ostream& out, const Gradient& obj);

typedef struct _ComputeNodeInfo__isset {
  _ComputeNodeInfo__isset() : ip(false), port(false), load_probability(false) {}
  bool ip :1;
  bool port :1;
  bool load_probability :1;
} _ComputeNodeInfo__isset;

class ComputeNodeInfo : public virtual ::apache::thrift::TBase {
 public:

  ComputeNodeInfo(const ComputeNodeInfo&);
  ComputeNodeInfo& operator=(const ComputeNodeInfo&);
  ComputeNodeInfo() noexcept
                  : ip(),
                    port(0),
                    load_probability(0) {
  }

  virtual ~ComputeNodeInfo() noexcept;
  std::string ip;
  int32_t port;
  double load_probability;

  _ComputeNodeInfo__isset __isset;

  void __set_ip(const std::string& val);

  void __set_port(const int32_t val);

  void __set_load_probability(const double val);

  bool operator == (const ComputeNodeInfo & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(load_probability == rhs.load_probability))
      return false;
    return true;
  }
  bool operator != (const ComputeNodeInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ComputeNodeInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ComputeNodeInfo &a, ComputeNodeInfo &b);

std::ostream& operator<<(std::ostream& out, const ComputeNodeInfo& obj);

} // namespace

#endif
