/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "distributedML_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace distributedML {


Weights::~Weights() noexcept {
}


void Weights::__set_W(const std::vector<std::vector<double> > & val) {
  this->W = val;
}

void Weights::__set_V(const std::vector<std::vector<double> > & val) {
  this->V = val;
}
std::ostream& operator<<(std::ostream& out, const Weights& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Weights::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->W.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->W.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              {
                this->W[_i4].clear();
                uint32_t _size5;
                ::apache::thrift::protocol::TType _etype8;
                xfer += iprot->readListBegin(_etype8, _size5);
                this->W[_i4].resize(_size5);
                uint32_t _i9;
                for (_i9 = 0; _i9 < _size5; ++_i9)
                {
                  xfer += iprot->readDouble(this->W[_i4][_i9]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.W = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->V.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->V.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              {
                this->V[_i14].clear();
                uint32_t _size15;
                ::apache::thrift::protocol::TType _etype18;
                xfer += iprot->readListBegin(_etype18, _size15);
                this->V[_i14].resize(_size15);
                uint32_t _i19;
                for (_i19 = 0; _i19 < _size15; ++_i19)
                {
                  xfer += iprot->readDouble(this->V[_i14][_i19]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.V = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Weights::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Weights");

  xfer += oprot->writeFieldBegin("W", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->W.size()));
    std::vector<std::vector<double> > ::const_iterator _iter20;
    for (_iter20 = this->W.begin(); _iter20 != this->W.end(); ++_iter20)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter20).size()));
        std::vector<double> ::const_iterator _iter21;
        for (_iter21 = (*_iter20).begin(); _iter21 != (*_iter20).end(); ++_iter21)
        {
          xfer += oprot->writeDouble((*_iter21));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("V", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->V.size()));
    std::vector<std::vector<double> > ::const_iterator _iter22;
    for (_iter22 = this->V.begin(); _iter22 != this->V.end(); ++_iter22)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter22).size()));
        std::vector<double> ::const_iterator _iter23;
        for (_iter23 = (*_iter22).begin(); _iter23 != (*_iter22).end(); ++_iter23)
        {
          xfer += oprot->writeDouble((*_iter23));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Weights &a, Weights &b) {
  using ::std::swap;
  swap(a.W, b.W);
  swap(a.V, b.V);
  swap(a.__isset, b.__isset);
}

Weights::Weights(const Weights& other24) {
  W = other24.W;
  V = other24.V;
  __isset = other24.__isset;
}
Weights& Weights::operator=(const Weights& other25) {
  W = other25.W;
  V = other25.V;
  __isset = other25.__isset;
  return *this;
}
void Weights::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Weights(";
  out << "W=" << to_string(W);
  out << ", " << "V=" << to_string(V);
  out << ")";
}


Gradient::~Gradient() noexcept {
}


void Gradient::__set_dW(const std::vector<std::vector<double> > & val) {
  this->dW = val;
}

void Gradient::__set_dV(const std::vector<std::vector<double> > & val) {
  this->dV = val;
}
std::ostream& operator<<(std::ostream& out, const Gradient& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Gradient::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dW.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->dW.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              {
                this->dW[_i30].clear();
                uint32_t _size31;
                ::apache::thrift::protocol::TType _etype34;
                xfer += iprot->readListBegin(_etype34, _size31);
                this->dW[_i30].resize(_size31);
                uint32_t _i35;
                for (_i35 = 0; _i35 < _size31; ++_i35)
                {
                  xfer += iprot->readDouble(this->dW[_i30][_i35]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dW = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dV.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->dV.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              {
                this->dV[_i40].clear();
                uint32_t _size41;
                ::apache::thrift::protocol::TType _etype44;
                xfer += iprot->readListBegin(_etype44, _size41);
                this->dV[_i40].resize(_size41);
                uint32_t _i45;
                for (_i45 = 0; _i45 < _size41; ++_i45)
                {
                  xfer += iprot->readDouble(this->dV[_i40][_i45]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dV = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Gradient::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Gradient");

  xfer += oprot->writeFieldBegin("dW", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->dW.size()));
    std::vector<std::vector<double> > ::const_iterator _iter46;
    for (_iter46 = this->dW.begin(); _iter46 != this->dW.end(); ++_iter46)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter46).size()));
        std::vector<double> ::const_iterator _iter47;
        for (_iter47 = (*_iter46).begin(); _iter47 != (*_iter46).end(); ++_iter47)
        {
          xfer += oprot->writeDouble((*_iter47));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dV", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->dV.size()));
    std::vector<std::vector<double> > ::const_iterator _iter48;
    for (_iter48 = this->dV.begin(); _iter48 != this->dV.end(); ++_iter48)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter48).size()));
        std::vector<double> ::const_iterator _iter49;
        for (_iter49 = (*_iter48).begin(); _iter49 != (*_iter48).end(); ++_iter49)
        {
          xfer += oprot->writeDouble((*_iter49));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Gradient &a, Gradient &b) {
  using ::std::swap;
  swap(a.dW, b.dW);
  swap(a.dV, b.dV);
  swap(a.__isset, b.__isset);
}

Gradient::Gradient(const Gradient& other50) {
  dW = other50.dW;
  dV = other50.dV;
  __isset = other50.__isset;
}
Gradient& Gradient::operator=(const Gradient& other51) {
  dW = other51.dW;
  dV = other51.dV;
  __isset = other51.__isset;
  return *this;
}
void Gradient::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Gradient(";
  out << "dW=" << to_string(dW);
  out << ", " << "dV=" << to_string(dV);
  out << ")";
}


ComputeNodeInfo::~ComputeNodeInfo() noexcept {
}


void ComputeNodeInfo::__set_ip(const std::string& val) {
  this->ip = val;
}

void ComputeNodeInfo::__set_port(const int32_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const ComputeNodeInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ComputeNodeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ComputeNodeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ComputeNodeInfo");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ComputeNodeInfo &a, ComputeNodeInfo &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

ComputeNodeInfo::ComputeNodeInfo(const ComputeNodeInfo& other52) {
  ip = other52.ip;
  port = other52.port;
  __isset = other52.__isset;
}
ComputeNodeInfo& ComputeNodeInfo::operator=(const ComputeNodeInfo& other53) {
  ip = other53.ip;
  port = other53.port;
  __isset = other53.__isset;
  return *this;
}
void ComputeNodeInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ComputeNodeInfo(";
  out << "ip=" << to_string(ip);
  out << ", " << "port=" << to_string(port);
  out << ")";
}

} // namespace
