// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "./gen-cpp/Coordinator.h"
#include "./gen-cpp/ComputeNode.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thread>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::distributedML;

class CoordinatorHandler : virtual public CoordinatorIf {
 public:
  CoordinatorHandler() {
    // Your initialization goes here
  }

  void load_compute_nodes(std::vector<ComputeNodeInfo> & _return, const std::string& filename) {
    ifstream file(filename);
    if (!file.is_open()) {
      cerr << "Error: Unable to open file " << filename << endl;
      return;
    }
    string line;
    while (getline(file, line)) {
      ComputeNodeInfo in;
      stringstream ss(line);
      char delimiter;
      if (!(ss >> in.ip >> delimiter >> in.port) || delimiter != ',') {
        cerr << "Error: Invalid format in file: " << line << endl;
        exit(1);
      }
      _return.emplace_back(in);
    }
    file.close();
  }

  double train(const std::string& dir, const int32_t rounds, const int32_t epochs, const int32_t h, const int32_t k, const double eta, const std::string& compute_nodes_file) {
    cout << "Coordinator: rounds: " << rounds << " epocks: " << epochs << " hidden unit: "
      << h << " output unit: " << k << " learning rate: " << eta << endl;

    // Initialize the global model
    mlp almighty;
    // only read the input data's format, weights are random
    almighty.init_training_random(dir + "/train_letters1.txt", k, h);

    Weights shared_weights;
    almighty.get_weights(shared_weights.V, shared_weights.W);

    queue<string> work_queue;
    for (int i = 1; i < 2; i++) {
        work_queue.push(dir + "/train_letters" + to_string(i) + ".txt");
    }

    vector<ComputeNodeInfo> compute_nodes;
    load_compute_nodes(compute_nodes, compute_nodes_file);
    if (compute_nodes.empty()) {
      cout << "Error: No compute nodes found in " << compute_nodes_file << endl;
      exit(1);
    }

    vector<vector<double>> shared_gradient_V(h + 1, vector<double>(k, 0));
    vector<vector<double>> shared_gradient_W(17, vector<double>(h, 0));
    auto thread_func = [&](int node_index) {
      while (true){
        if (work_queue.empty()) {
          return;
        }
        string training_file = work_queue.front();
        work_queue.pop();
        boost::shared_ptr<TTransport> socket(new TSocket(compute_nodes[node_index].ip, compute_nodes[node_index].port));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        ComputeNodeClient client(protocol);

        transport->open();
        Gradient grad;
        client.trainModel(grad, shared_weights, training_file, eta, epochs);
        transport->close();

        for (size_t i = 0; i < shared_gradient_V.size(); i++) {
          for (size_t j = 0; j < shared_gradient_V[i].size(); j++) {
              shared_gradient_V[i][j] += grad.dV[i][j];
          }
        }
        for (size_t i = 0; i < shared_gradient_W.size(); i++) {
          for (size_t j = 0; j < shared_gradient_W[i].size(); j++) {
              shared_gradient_W[i][j] += grad.dW[i][j];
          }
        }
      }
    };
    vector<thread> workers;
    for (int i = 0; i < compute_nodes.size(); i++) {
        workers.emplace_back(thread_func, i);
    }
    for (auto& worker : workers) {
        worker.join();
    }
    almighty.update_weights(shared_gradient_V, shared_gradient_W);
    double validation_error = almighty.validate(dir + "/validate_letters.txt");
    //cout << "Validation error: " << validation_error << endl;
    return validation_error;
  }

};

int main(int argc, char **argv) {
  if (argc != 3) {
      cout << "Usage: ./coordinator <port> <scheduling_policy>" << endl;
      exit(1);
  }
  int port = stoi(argv[1]);
  string policy = argv[2];
  ::std::shared_ptr<CoordinatorHandler> handler(new CoordinatorHandler());
  ::std::shared_ptr<TProcessor> processor(new CoordinatorProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}
